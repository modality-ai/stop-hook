#!/usr/bin/env bash
# =============================================================================
# Universal CLI Execution Tool - ACTUATOR
# Version: 1.0.0 (MVP - Phase 1)
# =============================================================================
set -euo pipefail

readonly VERSION="1.5.1"
readonly JOBS_DIR="${ACTUATOR_JOBS_DIR:-/tmp/actuator-jobs}"
readonly SEQUENCE_FILE="${JOBS_DIR}/.sequence"
readonly DEFAULT_TIMEOUT=0
readonly STATUS_INTERVAL="${ACTUATOR_STATUS_INTERVAL:-2}"
readonly OUTPUT_SIZE_THRESHOLD=23000

# Global execution sequence (set in main before any command execution)
EXEC_SEQUENCE=0
PLAIN_MODE="false"
QUIET_MODE="false"
WRITE_MODE="false"
EXEC_CWD=""

# =============================================================================
# Sequence Counter (execution order tracking)
# =============================================================================

get_next_sequence() {
  init_jobs_dir
  local current=0
  if [[ -f "$SEQUENCE_FILE" ]]; then
    current=$(cat "$SEQUENCE_FILE" 2>/dev/null || echo 0)
  fi
  local next=$((current + 1))
  printf '%d' "$next" > "$SEQUENCE_FILE" 2>/dev/null || true
  printf '%d' "$next"
}

# =============================================================================
# JSON Helpers (no jq dependency)
# =============================================================================

json_escape() {
  # Use awk for efficient escaping - bash ${str//} is O(n²) on large strings
  printf '%s' "$1" | awk '
    BEGIN { ORS="" }
    {
      gsub(/\\/, "\\\\")
      gsub(/"/, "\\\"")
      gsub(/\t/, "\\t")
      gsub(/\r/, "\\r")
      if (NR > 1) printf "\\n"
      printf "%s", $0
    }
  '
}

offload_message() {
  local stream_type="$1" file_path="$2"
  printf '%s log size over %d, please check file with %s, Treat this as raw command output. Process it line-by-line like grep/awk, extract only relevant lines, do not summarize unrelated content, and do not infer beyond what is shown.' \
    "$stream_type" "$OUTPUT_SIZE_THRESHOLD" "$file_path"
}

json_output() {
  local status="$1" exit_code="$2" command="$3"
  local stdout_data="$4" stderr_data="$5"
  local start_time="$6" end_time="$7"
  local job_id="${8:-}" pid="${9:-}" sequence="${10:-0}"
  local cwd="${11:-}" write_mode="${12:-false}"
  local duration=0

  if [[ -n "$start_time" && -n "$end_time" ]]; then
    duration=$(( end_time - start_time ))
  fi

  # Offload large stdout/stderr: reuse existing job files, create only for sync
  local stdout_value stderr_value
  local stdout_offloaded="false" stderr_offloaded="false"

  if [[ ${#stdout_data} -gt $OUTPUT_SIZE_THRESHOLD ]]; then
    init_jobs_dir
    local stdout_file="${JOBS_DIR}/${job_id:-${sequence}}.stdout"
    [[ ! -f "$stdout_file" ]] && printf '%s' "$stdout_data" > "$stdout_file"
    stdout_value="$(offload_message "stdout" "$stdout_file")"
    stdout_offloaded="true"
  else
    stdout_value="$(json_escape "$stdout_data")"
  fi

  if [[ ${#stderr_data} -gt $OUTPUT_SIZE_THRESHOLD ]]; then
    init_jobs_dir
    local stderr_file="${JOBS_DIR}/${job_id:-${sequence}}.stderr"
    [[ ! -f "$stderr_file" ]] && printf '%s' "$stderr_data" > "$stderr_file"
    stderr_value="$(offload_message "stderr" "$stderr_file")"
    stderr_offloaded="true"
  else
    stderr_value="$(json_escape "$stderr_data")"
  fi

  # Build JSON object as single line (JSONL format)
  local json_parts=()
  json_parts+=("\"version\":${sequence}")
  json_parts+=("\"status\":\"$(json_escape "$status")\"")

  [[ "$exit_code" -ne -1 ]] && json_parts+=("\"exit_code\":${exit_code}")

  json_parts+=("\"command\":\"$(json_escape "$command")\"")
  [[ -n "$cwd" ]] && json_parts+=("\"cwd\":\"$(json_escape "$cwd")\"")
  [[ "$write_mode" == "true" ]] && json_parts+=("\"write_mode\":true")
  json_parts+=("\"stdout\":\"${stdout_value}\"")
  [[ "$stdout_offloaded" == "true" ]] && json_parts+=("\"stdout_offloaded\":true")

  json_parts+=("\"stderr\":\"${stderr_value}\"")
  [[ "$stderr_offloaded" == "true" ]] && json_parts+=("\"stderr_offloaded\":true")

  json_parts+=("\"metadata\":{\"start_time\":${start_time:-0},\"end_time\":${end_time:-0},\"duration_seconds\":${duration},\"timestamp\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}")

  if [[ -n "$job_id" ]]; then
    json_parts+=("\"job\":{\"id\":\"$(json_escape "$job_id")\",\"pid\":${pid:-0}}")
  elif [[ -n "$pid" && "$pid" != "0" ]]; then
    json_parts+=("\"pid\":${pid}")
  fi

  # Join all parts with commas and wrap in braces
  local IFS=,
  printf '{%s}\n' "${json_parts[*]}"
}

plain_output() {
  local status="$1" exit_code="$2" command="$3"
  local stdout_data="$4" stderr_data="$5"
  local start_time="$6" end_time="$7"
  local job_id="${8:-}" pid="${9:-}"
  local _sequence="${10:-}" cwd="${11:-}" write_mode="${12:-false}"
  local duration=0

  if [[ -n "$start_time" && -n "$end_time" ]]; then
    duration=$(( end_time - start_time ))
  fi

  printf '%s\n' '------ Command Execution Result ------'
  printf 'Status: %s\n' "$status"
  [[ "$exit_code" -ne -1 ]] && printf 'Exit Code: %d\n' "$exit_code"
  printf 'Command: %s\n' "$command"
  [[ -n "$cwd" ]] && printf 'Working Directory: %s\n' "$cwd"
  [[ "$write_mode" == "true" ]] && printf 'Write Mode: yes\n'
  printf 'Duration: %d seconds\n' "$duration"

  if [[ -n "$job_id" ]]; then
    printf 'Job ID: %s\n' "$job_id"
    printf 'PID: %s\n' "${pid:-0}"
  elif [[ -n "$pid" && "$pid" != "0" ]]; then
    printf 'PID: %s\n' "$pid"
  fi

  if [[ -n "$stdout_data" ]]; then
    printf '%s\n' ''
    printf '%s\n' '------ Standard Output ------'
    printf '%s\n' "$stdout_data"
  fi

  if [[ -n "$stderr_data" ]]; then
    printf '%s\n' ''
    printf '%s\n' '------ Standard Error ------'
    printf '%s\n' "$stderr_data"
  fi
}

emit_result() {
  local write_mode="$1" plain="$2"
  shift 2
  # Remaining: status exit_code command stdout_data stderr_data start_time end_time [job_id] [pid] [sequence] [cwd] (write_mode appended below)
  local stdout_data="$4"

  # Write mode: pass command stdout through to actuator's stdout
  if [[ "$write_mode" == "true" && -n "$stdout_data" ]]; then
    printf '%s\n' "$stdout_data"
  fi

  # Output result (stderr in write mode, stdout normally)
  # Append write_mode as final positional arg for json_output/plain_output
  if [[ "$write_mode" == "true" ]]; then
    if [[ "$plain" == "true" ]]; then
      plain_output "$@" "$write_mode" >&2
    else
      json_output "$@" "$write_mode" >&2
    fi
  else
    if [[ "$plain" == "true" ]]; then
      plain_output "$@"
    else
      json_output "$@"
    fi
  fi
}

json_status_update() {
  [[ "$PLAIN_MODE" == "true" ]] && return
  local status="$1" job_id="$2" message="${3:-}"
  cat <<ENDJSON
{"event": "status_update", "status": "$(json_escape "$status")", "job_id": "$(json_escape "$job_id")", "message": "$(json_escape "$message")", "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"}
ENDJSON
}

json_stream_line() {
  local stream="$1" data="$2"
  if [[ "$PLAIN_MODE" == "true" ]]; then
    [[ "$QUIET_MODE" == "true" ]] && return
    if [[ "$stream" == "stderr" ]]; then
      printf '[stderr] %s\n' "$data"
    else
      printf '%s\n' "$data"
    fi
    return
  fi
  printf '{"event":"%s","status":"running","data":"%s","timestamp":"%s"}\n' \
    "$stream" "$(json_escape "$data")" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}

# =============================================================================
# Job Management
# =============================================================================

init_jobs_dir() {
  mkdir -p "$JOBS_DIR"
}

generate_job_id() {
  printf '%s_%s' "$(date +%s)" "$$"
}

# Write complete job file atomically (temp file + mv)
# Usage: write_job_file "$job_file" "KEY1='val1'" "KEY2='val2'" ...
write_job_file() {
  local job_file="$1"
  shift
  local tmp_file="${job_file}.tmp.${BASHPID:-$$}.${RANDOM}"
  printf '%s\n' "$@" > "$tmp_file"
  mv -f "$tmp_file" "$job_file"
}

# Update specific fields in job file atomically
# Reads current file, replaces matching keys or appends new ones,
# writes to temp file, then mv (POSIX atomic rename).
# Usage: update_job_fields "$job_file" "STATUS='completed'" "EXIT_CODE='0'"
update_job_fields() {
  local job_file="$1"
  shift
  [[ -f "$job_file" ]] || return 0

  local tmp_file="${job_file}.tmp.${BASHPID:-$$}.${RANDOM}"
  local updates=("$@")

  {
    while IFS= read -r line || [[ -n "$line" ]]; do
      local key="${line%%=*}"
      local replaced=false
      for i in "${!updates[@]}"; do
        local update_key="${updates[$i]%%=*}"
        if [[ "$key" == "$update_key" ]]; then
          printf '%s\n' "${updates[$i]}"
          unset 'updates[$i]'
          replaced=true
          break
        fi
      done
      [[ "$replaced" == "false" ]] && printf '%s\n' "$line"
    done < "$job_file"

    # Append any new fields not already in the file
    for update in "${updates[@]}"; do
      [[ -n "$update" ]] && printf '%s\n' "$update"
    done
  } > "$tmp_file"

  mv -f "$tmp_file" "$job_file"
}

save_job_state() {
  local job_id="$1" pid="$2" command="$3" status="$4" start_time="$5" cwd="${6:-}" write_mode="${7:-false}"
  local job_file="${JOBS_DIR}/${job_id}.job"
  write_job_file "$job_file" \
    "JOB_ID='${job_id}'" \
    "PID='${pid}'" \
    "COMMAND='${command//\'/\'\\\'\'}'" \
    "STATUS='${status}'" \
    "START_TIME='${start_time}'" \
    "CWD='${cwd//\'/\'\\\'\'}'" \
    "WRITE_MODE='${write_mode}'" \
    "STDOUT_FILE='${JOBS_DIR}/${job_id}.stdout'" \
    "STDERR_FILE='${JOBS_DIR}/${job_id}.stderr'"
}

update_job_status() {
  local job_id="$1" status="$2" exit_code="${3:-}"
  local job_file="${JOBS_DIR}/${job_id}.job"

  local updates=("STATUS='${status}'")
  if [[ -n "$exit_code" ]]; then
    updates+=("EXIT_CODE='${exit_code}'" "END_TIME='$(date +%s)'")
  fi
  update_job_fields "$job_file" "${updates[@]}"
}

load_job_state() {
  local job_id="$1"
  local job_file="${JOBS_DIR}/${job_id}.job"
  [[ -f "$job_file" ]] || { echo "Job not found: ${job_id}" >&2; return 1; }
  # shellcheck disable=SC1090
  source "$job_file"
}

# =============================================================================
# Signal Handling & Cleanup
# =============================================================================

kill_child() {
  local pid="$1" signal="${2:-TERM}"
  kill -"$signal" "$pid" 2>/dev/null || true
}

# Global state for signal handler (avoids quote escaping issues in trap strings)
TRAP_CMD_PID=""
TRAP_STDOUT_FILE=""
TRAP_STDERR_FILE=""
TRAP_COMMAND=""
TRAP_START_TIME=""
TIMEOUT_MONITOR_PID=""

handle_signal() {
  local signal_name="$1"
  local exit_code

  case "$signal_name" in
    INT)  exit_code=130 ;;
    TERM) exit_code=143 ;;
    *)    exit_code=1 ;;
  esac

  # Kill child process immediately
  if [[ -n "$TRAP_CMD_PID" ]]; then
    kill_child "$TRAP_CMD_PID" KILL
    wait "$TRAP_CMD_PID" 2>/dev/null || true
  fi

  # Kill timeout monitor if active
  if [[ -n "${TIMEOUT_MONITOR_PID:-}" ]]; then
    kill_child "$TIMEOUT_MONITOR_PID" KILL
    wait "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
  fi

  local end_time
  end_time=$(date +%s)

  # Capture whatever output was produced before interruption
  local stdout_data="" stderr_data=""
  [[ -f "$TRAP_STDOUT_FILE" ]] && stdout_data=$(cat "$TRAP_STDOUT_FILE" 2>/dev/null || true)
  [[ -f "$TRAP_STDERR_FILE" ]] && stderr_data=$(cat "$TRAP_STDERR_FILE" 2>/dev/null || true)

  rm -f "$TRAP_STDOUT_FILE" "$TRAP_STDERR_FILE"

  emit_result "$WRITE_MODE" "false" "interrupted" "$exit_code" "$TRAP_COMMAND" "$stdout_data" "$stderr_data" "$TRAP_START_TIME" "$end_time" "" "" "$EXEC_SEQUENCE" "$EXEC_CWD"
  exit "$exit_code"
}

# =============================================================================
# Timeout Monitor
# =============================================================================

start_timeout_monitor() {
  local pid="$1" timeout="$2"

  {
    sleep "$timeout" 2>/dev/null
    if kill -0 "$pid" 2>/dev/null; then
      kill_child "$pid" TERM
      sleep 2
      kill -0 "$pid" 2>/dev/null && kill_child "$pid" KILL
    fi
  } &
  TIMEOUT_MONITOR_PID=$!
}

# =============================================================================
# Core Execution: Synchronous
# =============================================================================

execute_sync() {
  local command="$1"
  local timeout="${2:-$DEFAULT_TIMEOUT}"
  local stream_output="${3:-false}"
  local plain="${4:-false}"
  local use_tty="${5:-false}"
  local quiet="${6:-false}"
  local write_mode="${7:-false}"

  local stdout_file stderr_file start_time end_time exit_code=0
  stdout_file=$(mktemp)
  stderr_file=$(mktemp)
  start_time=$(date +%s)

  if [[ "$stream_output" == "true" ]]; then
    json_status_update "running" "sync" "Executing: ${command}"
  fi

  # Foreground mode: run command directly (not backgrounded) to avoid
  # SIGTTIN/SIGTTOU signals that suspend backgrounded terminal processes.
  # Uses tee to BOTH display output on terminal AND capture to files.
  # Stdin stays as-is so commands like cdiff detect isatty(stdin) for VCS mode
  # and interactive commands like ssh get terminal input.
  if [[ "$use_tty" == "true" ]]; then
    # TTY Mode: Direct foreground execution OR polling for streaming with heartbeat
    if [[ "$stream_output" == "true" ]]; then
      # Streaming + TTY: Use polling loop to emit heartbeat events while maintaining TTY output
      # Background command but keep output flowing to terminal and files
      bash -c "$command" < /dev/stdin > "$stdout_file" 2> "$stderr_file" &
      local cmd_pid=$!

      # Set global state for signal handler
      TRAP_CMD_PID="$cmd_pid"
      TRAP_STDOUT_FILE="$stdout_file"
      TRAP_STDERR_FILE="$stderr_file"
      TRAP_COMMAND="$command"
      TRAP_START_TIME="$start_time"

      trap 'handle_signal INT' INT
      trap 'handle_signal TERM' TERM

      # Start timeout monitor if configured
      TIMEOUT_MONITOR_PID=""
      if [[ "$timeout" -gt 0 ]]; then
        start_timeout_monitor "$cmd_pid" "$timeout"
      fi

      # Also display output to terminal in real-time via tee
      if [[ "$quiet" != "true" ]]; then
        # Continuously tail output to terminal while polling for events
        tail -f "$stdout_file" 2>/dev/null &
        local tail_pid=$!
        tail -f "$stderr_file" 2>/dev/null >&2 &
        local tail_err_pid=$!
      fi

      # Polling loop with heartbeat events
      local stdout_lines=0 stderr_lines=0
      local poll_count=0
      local heartbeat_every=$(( ${STATUS_INTERVAL%.*} * 5 ))
      [[ "$heartbeat_every" -lt 5 ]] && heartbeat_every=5

      while kill -0 "$cmd_pid" 2>/dev/null; do
        local had_output=false

        # Emit new stdout lines
        local current_out
        current_out=$(wc -l < "$stdout_file" 2>/dev/null | tr -d ' ')
        if [[ "${current_out:-0}" -gt "$stdout_lines" ]]; then
          tail -n +"$((stdout_lines + 1))" "$stdout_file" 2>/dev/null | while IFS= read -r line; do
            json_stream_line "stdout" "$line"
          done
          stdout_lines="$current_out"
          had_output=true
        fi

        # Emit new stderr lines
        local current_err
        current_err=$(wc -l < "$stderr_file" 2>/dev/null | tr -d ' ')
        if [[ "${current_err:-0}" -gt "$stderr_lines" ]]; then
          tail -n +"$((stderr_lines + 1))" "$stderr_file" 2>/dev/null | while IFS= read -r line; do
            json_stream_line "stderr" "$line"
          done
          stderr_lines="$current_err"
          had_output=true
        fi

        # Heartbeat: emit status even when no new output
        (( poll_count++ )) || true
        if [[ "$had_output" == "false" && $(( poll_count % heartbeat_every )) -eq 0 ]]; then
          local elapsed=$(( $(date +%s) - start_time ))
          local out_bytes err_bytes
          out_bytes=$(wc -c < "$stdout_file" 2>/dev/null | tr -d ' ')
          err_bytes=$(wc -c < "$stderr_file" 2>/dev/null | tr -d ' ')
          if [[ "$PLAIN_MODE" == "true" ]]; then
            [[ "$QUIET_MODE" != "true" ]] && printf '[heartbeat] running %ds stdout=%sB stderr=%sB\n' \
              "$elapsed" "${out_bytes:-0}" "${err_bytes:-0}"
          else
            printf '{"event":"heartbeat","status":"running","elapsed_seconds":%d,"stdout_bytes":%s,"stderr_bytes":%s,"pid":%d,"timestamp":"%s"}\n' \
              "$elapsed" "${out_bytes:-0}" "${err_bytes:-0}" "$cmd_pid" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          fi
        fi

        sleep 0.2 &
        wait $! 2>/dev/null || true
      done

      # Clean up tail processes if used
      if [[ "$quiet" != "true" ]]; then
        kill "$tail_pid" "$tail_err_pid" 2>/dev/null || true
        wait "$tail_pid" "$tail_err_pid" 2>/dev/null || true
      fi

      # Flush any remaining lines after process exits
      tail -n +"$((stdout_lines + 1))" "$stdout_file" 2>/dev/null | while IFS= read -r line; do
        json_stream_line "stdout" "$line"
      done
      tail -n +"$((stderr_lines + 1))" "$stderr_file" 2>/dev/null | while IFS= read -r line; do
        json_stream_line "stderr" "$line"
      done

      wait "$cmd_pid" 2>/dev/null || exit_code=$?
      end_time=$(date +%s)

      # Kill timeout monitor if active
      if [[ -n "$TIMEOUT_MONITOR_PID" ]]; then
        kill "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
        wait "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
      fi

      local status="completed"
      if [[ "$timeout" -gt 0 && ( "$exit_code" -eq 137 || "$exit_code" -eq 143 ) ]]; then
        status="timeout"
      elif [[ "$exit_code" -ne 0 ]]; then
        status="failed"
      fi

      local stdout_data stderr_data
      stdout_data=$(cat "$stdout_file" 2>/dev/null || true)
      stderr_data=$(cat "$stderr_file" 2>/dev/null || true)
      rm -f "$stdout_file" "$stderr_file"

      emit_result "$write_mode" "$plain" "$status" "$exit_code" "$command" "$stdout_data" "$stderr_data" "$start_time" "$end_time" "" "$cmd_pid" "$EXEC_SEQUENCE" "$EXEC_CWD"
      return
    fi

    # Non-streaming TTY: Direct foreground execution (original behavior)
    if [[ "$timeout" -gt 0 ]]; then
      start_timeout_monitor "$$" "$timeout"
    fi

    if [[ "$quiet" == "true" || "$write_mode" == "true" ]]; then
      # Quiet/write mode: capture only, no tee (emit_result handles pass-through in write mode)
      bash -c "$command" > "$stdout_file" 2> "$stderr_file" || exit_code=$?
    else
      # Normal mode: display to terminal while capturing
      bash -c "$command" > >(tee "$stdout_file") 2> >(tee "$stderr_file" >&2) || exit_code=$?
    fi
    end_time=$(date +%s)

    if [[ -n "$TIMEOUT_MONITOR_PID" ]]; then
      kill "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
      wait "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
    fi

    # Allow tee processes to flush
    wait 2>/dev/null || true

    local status="completed"
    if [[ "$timeout" -gt 0 && ( "$exit_code" -eq 137 || "$exit_code" -eq 143 ) ]]; then
      status="timeout"
    elif [[ "$exit_code" -ne 0 ]]; then
      status="failed"
    fi

    local stdout_data stderr_data
    stdout_data=$(cat "$stdout_file" 2>/dev/null || true)
    stderr_data=$(cat "$stderr_file" 2>/dev/null || true)
    rm -f "$stdout_file" "$stderr_file"

    emit_result "$write_mode" "$plain" "$status" "$exit_code" "$command" "$stdout_data" "$stderr_data" "$start_time" "$end_time" "" "" "$EXEC_SEQUENCE" "$EXEC_CWD"
    return
  fi

  # Non-TTY mode: background with output capture
  # This path is used when stdin is piped (not a terminal).
  # NOTE: < /dev/stdin preserves piped input to child process
  bash -c "$command" < /dev/stdin > "$stdout_file" 2> "$stderr_file" &
  local cmd_pid=$!

  # Set global state for signal handler
  TRAP_CMD_PID="$cmd_pid"
  TRAP_STDOUT_FILE="$stdout_file"
  TRAP_STDERR_FILE="$stderr_file"
  TRAP_COMMAND="$command"
  TRAP_START_TIME="$start_time"

  trap 'handle_signal INT' INT
  trap 'handle_signal TERM' TERM

  # Start timeout monitor if configured
  TIMEOUT_MONITOR_PID=""
  if [[ "$timeout" -gt 0 ]]; then
    start_timeout_monitor "$cmd_pid" "$timeout"
  fi

  # Wait for command with signal-responsive loop
  if [[ "$stream_output" == "true" ]]; then
    # Poll for new lines and emit as JSON events (no background processes to leak)
    local stdout_lines=0 stderr_lines=0
    local poll_count=0
    local heartbeat_every=$(( ${STATUS_INTERVAL%.*} * 5 ))  # heartbeat every N polls
    [[ "$heartbeat_every" -lt 5 ]] && heartbeat_every=5

    while kill -0 "$cmd_pid" 2>/dev/null; do
      local had_output=false

      # Emit new stdout lines
      local current_out
      current_out=$(wc -l < "$stdout_file" 2>/dev/null | tr -d ' ')
      if [[ "${current_out:-0}" -gt "$stdout_lines" ]]; then
        tail -n +"$((stdout_lines + 1))" "$stdout_file" 2>/dev/null | while IFS= read -r line; do
          json_stream_line "stdout" "$line"
        done
        stdout_lines="$current_out"
        had_output=true
      fi

      # Emit new stderr lines
      local current_err
      current_err=$(wc -l < "$stderr_file" 2>/dev/null | tr -d ' ')
      if [[ "${current_err:-0}" -gt "$stderr_lines" ]]; then
        tail -n +"$((stderr_lines + 1))" "$stderr_file" 2>/dev/null | while IFS= read -r line; do
          json_stream_line "stderr" "$line"
        done
        stderr_lines="$current_err"
        had_output=true
      fi

      # Heartbeat: emit status even when no new output
      (( poll_count++ )) || true
      if [[ "$had_output" == "false" && $(( poll_count % heartbeat_every )) -eq 0 ]]; then
        local elapsed=$(( $(date +%s) - start_time ))
        local out_bytes err_bytes
        out_bytes=$(wc -c < "$stdout_file" 2>/dev/null | tr -d ' ')
        err_bytes=$(wc -c < "$stderr_file" 2>/dev/null | tr -d ' ')
        if [[ "$PLAIN_MODE" == "true" ]]; then
          printf '[heartbeat] running %ds stdout=%sB stderr=%sB\n' \
            "$elapsed" "${out_bytes:-0}" "${err_bytes:-0}"
        else
          printf '{"event":"heartbeat","status":"running","elapsed_seconds":%d,"stdout_bytes":%s,"stderr_bytes":%s,"pid":%d,"timestamp":"%s"}\n' \
            "$elapsed" "${out_bytes:-0}" "${err_bytes:-0}" "$cmd_pid" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        fi
      fi

      sleep 0.2 &
      wait $! 2>/dev/null || true
    done

    # Flush any remaining lines after process exits
    tail -n +"$((stdout_lines + 1))" "$stdout_file" 2>/dev/null | while IFS= read -r line; do
      json_stream_line "stdout" "$line"
    done
    tail -n +"$((stderr_lines + 1))" "$stderr_file" 2>/dev/null | while IFS= read -r line; do
      json_stream_line "stderr" "$line"
    done
  else
    while kill -0 "$cmd_pid" 2>/dev/null; do
      sleep 0.1 &
      wait $! 2>/dev/null || true
    done
  fi

  wait "$cmd_pid" 2>/dev/null || exit_code=$?
  end_time=$(date +%s)

  # Kill timeout monitor if active
  if [[ -n "$TIMEOUT_MONITOR_PID" ]]; then
    kill "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
    wait "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
  fi

  # Check if killed by timeout (SIGTERM=143, SIGKILL=137)
  local status="completed"
  if [[ "$timeout" -gt 0 && ( "$exit_code" -eq 137 || "$exit_code" -eq 143 ) ]]; then
    status="timeout"
  elif [[ "$exit_code" -ne 0 ]]; then
    status="failed"
  fi

  local stdout_data stderr_data
  stdout_data=$(cat "$stdout_file" 2>/dev/null || true)
  stderr_data=$(cat "$stderr_file" 2>/dev/null || true)

  rm -f "$stdout_file" "$stderr_file"

  emit_result "$write_mode" "$plain" "$status" "$exit_code" "$command" "$stdout_data" "$stderr_data" "$start_time" "$end_time" "" "$cmd_pid" "$EXEC_SEQUENCE" "$EXEC_CWD"
}

# =============================================================================
# Core Execution: Asynchronous
# =============================================================================

execute_async() {
  local command="$1"
  local timeout="${2:-$DEFAULT_TIMEOUT}"
  local plain="${3:-false}"
  local use_tty="${4:-false}"
  local quiet="${5:-false}"
  local custom_job_id="${6:-}"
  local write_mode="${7:-false}"

  init_jobs_dir
  local job_id
  if [[ -n "$custom_job_id" ]]; then
    job_id="$custom_job_id"
  else
    job_id=$(generate_job_id)
  fi
  local stdout_file="${JOBS_DIR}/${job_id}.stdout"
  local stderr_file="${JOBS_DIR}/${job_id}.stderr"
  local start_time
  start_time=$(date +%s)

  # Save job state BEFORE launching process
  save_job_state "$job_id" "0" "$command" "running" "$start_time" "$EXEC_CWD" "$write_mode"

  # Create output files to ensure they exist
  touch "$stdout_file" "$stderr_file"

  # Write mode: background + wait to capture real PID, still blocks until done
  if [[ "$write_mode" == "true" ]]; then
    local exit_code=0
    bash -c "$command" >"$stdout_file" 2>"$stderr_file" &
    local cmd_pid=$!

    update_job_fields "${JOBS_DIR}/${job_id}.job" "PID='${cmd_pid}'"

    # Set global state for signal handler
    TRAP_CMD_PID="$cmd_pid"
    TRAP_STDOUT_FILE="$stdout_file"
    TRAP_STDERR_FILE="$stderr_file"
    TRAP_COMMAND="$command"
    TRAP_START_TIME="$start_time"

    trap 'handle_signal INT' INT
    trap 'handle_signal TERM' TERM

    # Start timeout monitor if configured
    TIMEOUT_MONITOR_PID=""
    if [[ "$timeout" -gt 0 ]]; then
      start_timeout_monitor "$cmd_pid" "$timeout"
    fi

    wait "$cmd_pid" 2>/dev/null || exit_code=$?
    local end_time
    end_time=$(date +%s)

    # Kill timeout monitor if active
    if [[ -n "$TIMEOUT_MONITOR_PID" ]]; then
      kill "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
      wait "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
    fi

    local status="completed"
    if [[ "$timeout" -gt 0 && ( "$exit_code" -eq 137 || "$exit_code" -eq 143 ) ]]; then
      status="timeout"
    elif [[ "$exit_code" -ne 0 ]]; then
      status="failed"
    fi

    update_job_status "$job_id" "$status" "$exit_code"

    local stdout_data stderr_data
    stdout_data=$(cat "$stdout_file" 2>/dev/null || true)
    stderr_data=$(cat "$stderr_file" 2>/dev/null || true)

    emit_result "$write_mode" "$plain" "$status" "$exit_code" "$command" "$stdout_data" "$stderr_data" "$start_time" "$end_time" "$job_id" "$cmd_pid" "$EXEC_SEQUENCE" "$EXEC_CWD"
    return
  fi

  # Background mode: fire-and-forget with job tracking
  {
    local exit_code=0
    bash -c "$command" >"$stdout_file" 2>"$stderr_file" || exit_code=$?

    # Update job state atomically on completion
    if [[ $exit_code -eq 0 ]]; then
      update_job_status "$job_id" "completed" "0"
    else
      update_job_status "$job_id" "failed" "$exit_code"
    fi
  } &
  local cmd_pid=$!

  # Update with actual process ID (atomic)
  update_job_fields "${JOBS_DIR}/${job_id}.job" "PID='${cmd_pid}'"

  # Start timeout monitor if configured
  if [[ "$timeout" -gt 0 ]]; then
    start_timeout_monitor "$cmd_pid" "$timeout"
  fi

  emit_result "$write_mode" "$plain" "running" "-1" "$command" "" "" "$start_time" "" "$job_id" "$cmd_pid" "$EXEC_SEQUENCE" "$EXEC_CWD"
}

# =============================================================================
# Job Operations
# =============================================================================

poll_job() {
  local job_id="$1"
  local plain="${2:-false}"
  local JOB_ID PID COMMAND STATUS START_TIME STDOUT_FILE STDERR_FILE EXIT_CODE END_TIME CWD WRITE_MODE

  load_job_state "$job_id" || {
    if [[ "$plain" == "true" ]]; then
      printf '%s\n' "------ Error ------" >&2
      printf 'Job not found: %s\n' "$job_id" >&2
    else
      printf '{"status":"error","error":"Job not found","job_id":"%s"}\n' "$job_id"
    fi
    return 1
  }

  # Check if process is still running
  if [[ "$STATUS" == "running" ]] && ! kill -0 "$PID" 2>/dev/null; then
    wait "$PID" 2>/dev/null
    local actual_exit=$?
    if [[ "$actual_exit" -eq 0 ]]; then
      STATUS="completed"
    else
      STATUS="failed"
    fi
    update_job_status "$job_id" "$STATUS" "$actual_exit"
    EXIT_CODE="$actual_exit"
    END_TIME=$(date +%s)
  fi

  local stdout_data="" stderr_data=""
  [[ -f "$STDOUT_FILE" ]] && stdout_data=$(cat "$STDOUT_FILE" 2>/dev/null || true)
  [[ -f "$STDERR_FILE" ]] && stderr_data=$(cat "$STDERR_FILE" 2>/dev/null || true)

  if [[ "$plain" == "true" ]]; then
    plain_output "$STATUS" "${EXIT_CODE:--1}" "$COMMAND" "$stdout_data" "$stderr_data" \
      "$START_TIME" "${END_TIME:-}" "$JOB_ID" "$PID" "$EXEC_SEQUENCE" "${CWD:-}" "${WRITE_MODE:-false}"
  else
    json_output "$STATUS" "${EXIT_CODE:--1}" "$COMMAND" "$stdout_data" "$stderr_data" \
      "$START_TIME" "${END_TIME:-}" "$JOB_ID" "$PID" "$EXEC_SEQUENCE" "${CWD:-}" "${WRITE_MODE:-false}"
  fi
}

poll_job_stream() {
  local job_id="$1"
  local plain="${2:-false}"
  local JOB_ID PID COMMAND STATUS START_TIME STDOUT_FILE STDERR_FILE EXIT_CODE END_TIME CWD WRITE_MODE
  local poll_count=0
  local heartbeat_every=$(( ${STATUS_INTERVAL%.*} * 5 ))
  [[ "$heartbeat_every" -lt 5 ]] && heartbeat_every=5

  load_job_state "$job_id" || {
    if [[ "$plain" == "true" ]]; then
      printf '%s\n' "------ Error ------" >&2
      printf 'Job not found: %s\n' "$job_id" >&2
    else
      printf '{"status":"error","error":"Job not found","job_id":"%s"}\n' "$job_id"
    fi
    return 1
  }

  if [[ "$plain" == "true" ]]; then
    printf '%s\n' "------ Monitoring ------"
    printf 'Job %s: %s\n' "$job_id" "$COMMAND"
  else
    json_status_update "running" "$job_id" "Monitoring job: $COMMAND"
  fi

  local stdout_lines=0 stderr_lines=0
  local initial_status="$STATUS"

  # Polling loop with heartbeat events
  while true; do
    # Reload job state
    load_job_state "$job_id" || break

    # Check if process is still running
    if [[ "$STATUS" == "running" ]] && ! kill -0 "$PID" 2>/dev/null; then
      wait "$PID" 2>/dev/null
      local actual_exit=$?
      if [[ "$actual_exit" -eq 0 ]]; then
        STATUS="completed"
      else
        STATUS="failed"
      fi
      update_job_status "$job_id" "$STATUS" "$actual_exit"
      EXIT_CODE="$actual_exit"
      END_TIME=$(date +%s)
    fi

    local had_output=false
    local lines_to_emit

    # Emit new stdout lines
    if [[ -f "$STDOUT_FILE" ]]; then
      local current_out
      current_out=$(wc -l < "$STDOUT_FILE" 2>/dev/null | tr -d ' ')
      if [[ "${current_out:-0}" -gt "$stdout_lines" ]]; then
        lines_to_emit=$(tail -n +"$((stdout_lines + 1))" "$STDOUT_FILE" 2>/dev/null)
        while IFS= read -r line; do
          if [[ "$plain" == "true" ]]; then
            printf '%s\n' "$line"
          else
            json_stream_line "stdout" "$line"
          fi
        done <<< "$lines_to_emit"
        stdout_lines="$current_out"
        had_output=true
      fi
    fi

    # Emit new stderr lines
    if [[ -f "$STDERR_FILE" ]]; then
      local current_err
      current_err=$(wc -l < "$STDERR_FILE" 2>/dev/null | tr -d ' ')
      if [[ "${current_err:-0}" -gt "$stderr_lines" ]]; then
        lines_to_emit=$(tail -n +"$((stderr_lines + 1))" "$STDERR_FILE" 2>/dev/null)
        while IFS= read -r line; do
          if [[ "$plain" == "true" ]]; then
            printf '[stderr] %s\n' "$line"
          else
            json_stream_line "stderr" "$line"
          fi
        done <<< "$lines_to_emit"
        stderr_lines="$current_err"
        had_output=true
      fi
    fi

    # Heartbeat: emit status even when no new output
    (( poll_count++ )) || true
    if [[ "$had_output" == "false" && $(( poll_count % heartbeat_every )) -eq 0 ]]; then
      local out_bytes=0 err_bytes=0
      [[ -f "$STDOUT_FILE" ]] && out_bytes=$(wc -c < "$STDOUT_FILE" 2>/dev/null | tr -d ' ')
      [[ -f "$STDERR_FILE" ]] && err_bytes=$(wc -c < "$STDERR_FILE" 2>/dev/null | tr -d ' ')
      if [[ "$plain" == "true" ]]; then
        local elapsed=$(( $(date +%s) - START_TIME ))
        printf '[heartbeat] %s %ds stdout=%sB stderr=%sB\n' \
          "$STATUS" "$elapsed" "${out_bytes:-0}" "${err_bytes:-0}"
      else
        printf '{"event":"heartbeat","status":"%s","job_id":"%s","pid":%d,"stdout_bytes":%s,"stderr_bytes":%s,"timestamp":"%s"}\n' \
          "$STATUS" "$job_id" "$PID" "${out_bytes:-0}" "${err_bytes:-0}" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
      fi
    fi

    # Break if job is done
    if [[ "$STATUS" != "running" ]]; then
      # Emit final state
      local stdout_data="" stderr_data=""
      [[ -f "$STDOUT_FILE" ]] && stdout_data=$(cat "$STDOUT_FILE" 2>/dev/null || true)
      [[ -f "$STDERR_FILE" ]] && stderr_data=$(cat "$STDERR_FILE" 2>/dev/null || true)
      if [[ "$plain" == "true" ]]; then
        plain_output "$STATUS" "${EXIT_CODE:--1}" "$COMMAND" "$stdout_data" "$stderr_data" \
          "$START_TIME" "${END_TIME:-}" "$JOB_ID" "$PID" "$EXEC_SEQUENCE" "${CWD:-}" "${WRITE_MODE:-false}"
      else
        json_output "$STATUS" "${EXIT_CODE:--1}" "$COMMAND" "$stdout_data" "$stderr_data" \
          "$START_TIME" "${END_TIME:-}" "$JOB_ID" "$PID" "$EXEC_SEQUENCE" "${CWD:-}" "${WRITE_MODE:-false}"
      fi
      break
    fi

    sleep 0.2 &
    wait $! 2>/dev/null || true
  done
}

terminate_job() {
  local job_id="$1"
  local signal="${2:-TERM}"
  local JOB_ID PID COMMAND STATUS START_TIME STDOUT_FILE STDERR_FILE

  load_job_state "$job_id" || {
    if [[ "$PLAIN_MODE" == "true" ]]; then
      printf '%s\n' "------ Error ------" >&2
      printf 'Job not found: %s\n' "$job_id" >&2
    else
      printf '{"status":"error","error":"Job not found","job_id":"%s"}\n' "$job_id"
    fi
    return 1
  }

  if kill -0 "$PID" 2>/dev/null; then
    kill -"$signal" "$PID" 2>/dev/null
    sleep 1
    if kill -0 "$PID" 2>/dev/null && [[ "$signal" != "KILL" ]]; then
      kill -KILL "$PID" 2>/dev/null
    fi
    update_job_status "$job_id" "terminated" "143"
    json_status_update "terminated" "$job_id" "Process terminated with signal ${signal}"
  else
    json_status_update "already_stopped" "$job_id" "Process is not running"
  fi
}

terminate_all_jobs() {
  init_jobs_dir
  local terminated_count=0
  local jobs_json=""

  for job_file in "${JOBS_DIR}"/*.job; do
    [[ -f "$job_file" ]] || continue

    local JOB_ID="" PID="" COMMAND="" STATUS=""
    # shellcheck disable=SC1090
    source "$job_file" || continue

    # Only terminate if running and PID is valid (not 0 or empty)
    if [[ "$STATUS" == "running" ]] && [[ -n "$PID" && "$PID" != "0" ]] && kill -0 "$PID" 2>/dev/null; then
      kill -TERM "$PID" 2>/dev/null || true
      sleep 0.5
      kill -0 "$PID" 2>/dev/null && kill -KILL "$PID" 2>/dev/null || true
      update_job_status "$JOB_ID" "terminated" "143" || true

      if [[ -n "$jobs_json" ]]; then
        jobs_json="${jobs_json},"
      fi
      jobs_json="${jobs_json}{\"job_id\":\"$(json_escape "$JOB_ID")\",\"pid\":${PID},\"command\":\"$(json_escape "$COMMAND")\"}"
      ((terminated_count++)) || true
    fi
  done

  printf '{"terminated_jobs":[%s],"count":%d,"timestamp":"%s"}\n' \
    "$jobs_json" "$terminated_count" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}

# Fast job list: single awk pass over all job files (avoids N source + json_escape subprocesses)
# Job file format: KEY='VALUE' lines where single quotes in VALUE are escaped as '\''

list_jobs_json_fast() {
  local timestamp="$1" total="$2"
  shift 2
  # shellcheck disable=SC2016
  awk -v ts="$timestamp" -v total="$total" -v sq="'" '
  function val(line,    i, v) {
    i = index(line, "=")
    if (i == 0) return ""
    v = substr(line, i + 1)
    if (length(v) >= 2 && substr(v, 1, 1) == sq && substr(v, length(v), 1) == sq)
      v = substr(v, 2, length(v) - 2)
    gsub(sq "\\\\" sq sq, sq, v)
    return v
  }
  function jesc(s) {
    gsub(/\\/, "\\\\", s)
    gsub(/"/, "\\\"", s)
    gsub(/\t/, "\\t", s)
    gsub(/\r/, "\\r", s)
    return s
  }
  function flush(    sep) {
    if (jid == "") return
    if (st == "running" && pid ~ /^[0-9]+$/ && pid != "0") {
      if (system("kill -0 " pid " >/dev/null 2>&1") != 0) st = "completed"
    }
    sep = (n > 0) ? "," : ""
    printf "%s{\"job_id\":\"%s\",\"pid\":%s,\"status\":\"%s\",\"command\":\"%s\",\"start_time\":%s}",
      sep, jesc(jid), (pid != "" ? pid : "0"), jesc(st), jesc(cmd), (stime != "" ? stime : "0")
    n++
  }
  BEGIN { n = 0; printf "{\"jobs\":[" }
  FNR == 1 { flush(); jid=""; pid=""; cmd=""; st=""; stime="" }
  /^JOB_ID=/     { jid = val($0) }
  /^PID=/        { pid = val($0) }
  /^COMMAND=/    { cmd = val($0) }
  /^STATUS=/     { st = val($0) }
  /^START_TIME=/ { stime = val($0) }
  END {
    flush()
    printf "],\"count\":%d,\"total\":%d,\"timestamp\":\"%s\"}\n", n, total+0, ts
  }
  ' "$@"
}

list_jobs_plain_fast() {
  local timestamp="$1" total="$2"
  shift 2
  # shellcheck disable=SC2016
  awk -v ts="$timestamp" -v total="$total" -v sq="'" '
  function val(line,    i, v) {
    i = index(line, "=")
    if (i == 0) return ""
    v = substr(line, i + 1)
    if (length(v) >= 2 && substr(v, 1, 1) == sq && substr(v, length(v), 1) == sq)
      v = substr(v, 2, length(v) - 2)
    gsub(sq "\\\\" sq sq, sq, v)
    return v
  }
  function flush(    cd) {
    if (jid == "") return
    if (st == "running" && pid ~ /^[0-9]+$/ && pid != "0") {
      if (system("kill -0 " pid " >/dev/null 2>&1") != 0) st = "completed"
    }
    cd = (length(cmd) > 48) ? substr(cmd, 1, 48) "..." : cmd
    printf "%-25s %-8s %-12s %-50s %s\n", jid, pid, st, cd, stime
    n++
  }
  function sep(    i) { for (i = 0; i < 130; i++) printf "-"; printf "\n" }
  BEGIN {
    n = 0
    printf "------ Jobs List ------\n"
    printf "%-25s %-8s %-12s %-50s %s\n", "JOB ID", "PID", "STATUS", "COMMAND", "START TIME"
    sep()
  }
  FNR == 1 { flush(); jid=""; pid=""; cmd=""; st=""; stime="" }
  /^JOB_ID=/     { jid = val($0) }
  /^PID=/        { pid = val($0) }
  /^COMMAND=/    { cmd = val($0) }
  /^STATUS=/     { st = val($0) }
  /^START_TIME=/ { stime = val($0) }
  END {
    flush()
    if (n > 0) sep()
    shown = (total+0 > 0 && n < total+0) ? sprintf(" (showing %d of %d)", n, total+0) : ""
    printf "Total: %d job(s)%s | Updated: %s\n", n, shown, ts
  }
  ' "$@"
}

list_jobs() {
  init_jobs_dir
  local plain="${1:-false}" limit="${2:-0}"

  # Collect job files
  local job_files=()
  for f in "${JOBS_DIR}"/*.job; do
    [[ -f "$f" ]] && job_files+=("$f")
  done

  local total=${#job_files[@]}

  if [[ $total -eq 0 ]]; then
    local ts
    ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    if [[ "$plain" == "true" ]]; then
      printf '%s\n' '------ Jobs List ------'
      printf 'Total: 0 job(s) | Updated: %s\n' "$ts"
    else
      printf '{"jobs":[],"count":0,"total":0,"timestamp":"%s"}\n' "$ts"
    fi
    return
  fi

  # Sort newest first by modification time (handles both auto-generated and custom job IDs)
  IFS=$'\n' job_files=($(ls -1t "${job_files[@]}"))
  unset IFS

  # Apply limit
  if [[ "$limit" -gt 0 && "$limit" -lt "$total" ]]; then
    job_files=("${job_files[@]:0:$limit}")
  fi

  local timestamp
  timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)

  if [[ "$plain" == "true" ]]; then
    list_jobs_plain_fast "$timestamp" "$total" "${job_files[@]}"
  else
    list_jobs_json_fast "$timestamp" "$total" "${job_files[@]}"
  fi
}

cleanup_jobs() {
  init_jobs_dir
  local cleaned=0
  shopt -s nullglob  # Make glob expand to nothing if no matches
  for job_file in "${JOBS_DIR}"/*.job; do
    local JOB_ID="" PID="" STATUS=""
    # shellcheck disable=SC1090
    source "$job_file" || continue

    # Check if job is finished or process is dead
    local should_clean=false
    if [[ "$STATUS" != "running" ]]; then
      should_clean=true
    elif [[ -z "$PID" || "$PID" == "0" ]]; then
      # Invalid PID - clean up orphaned job
      should_clean=true
    elif ! kill -0 "$PID" 2>/dev/null; then
      # Process is dead
      should_clean=true
    fi

    if [[ "$should_clean" == "true" ]]; then
      rm -f "$job_file" "${JOBS_DIR}/${JOB_ID}.stdout" "${JOBS_DIR}/${JOB_ID}.stderr"
      ((cleaned++))
    fi
  done
  # Clean up orphaned stdout/stderr files (sync offloads without matching .job)
  local orphaned=0
  for output_file in "${JOBS_DIR}"/*.stdout "${JOBS_DIR}"/*.stderr; do
    [[ -f "$output_file" ]] || continue
    local base="${output_file%.*}"
    base="${base##*/}"
    [[ -f "${JOBS_DIR}/${base}.job" ]] && continue
    rm -f "$output_file"
    ((orphaned++))
  done
  shopt -u nullglob  # Reset
  printf '{"cleaned": %d, "orphaned_cleaned": %d, "timestamp": "%s"}\n' "$cleaned" "$orphaned" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}

# =============================================================================
# Usage
# =============================================================================

usage() {
  printf 'Universal CLI Execution Tool v%s\n' "$VERSION"
  cat <<'EOF'

USAGE:
  actuator [OPTIONS] <command>
  actuator [OPTIONS] --- <command args...>
  actuator [OPTIONS] --stdin
  echo "command" | actuator [OPTIONS]
  actuator --poll <job_id>
  actuator --terminate <job_id> [signal]
  actuator --terminate-all
  actuator --list
  actuator --cleanup

OPTIONS:
  -c, --command <cmd>     Command to execute
  -a, --async             Execute asynchronously (returns job ID)
  -j, --job-id <id>       Custom job ID for async execution (default: auto-generated)
  -s, --stream            Stream real-time status updates (sync mode or with -p for async)
  -t, --timeout <sec>     Timeout in seconds (0 = no timeout)
  -p, --poll <job_id>     Poll status of async job (use -s for continuous monitoring)
  -k, --terminate <id>    Terminate async job
  --terminate-all         Terminate all running jobs
  -l, --list              List all tracked jobs (JSON output, use --plain for table format)
  -n, --limit <N>         Limit job list to N most recent entries (use with -l)
  --cleanup               Remove completed job artifacts
  --stdin                 Read command from stdin (for shell metacharacters)
  --plain                 Output plain text instead of JSON
  -w, --write             Write mode: pass command stdout to actuator stdout,
                          output JSON/plain result to stderr. Use for commands
                          with shell redirects (e.g., actuator -w --- echo 1 > file)
  -q, --quiet             Suppress command output from terminal and metadata
  --init                  Output shell function for eval (enables cd through actuator)
  -v, --version           Show version
  -h, --help              Show this help

EXAMPLES:
  # Synchronous execution
  actuator "echo 'hello world'"
  actuator -c "ls -la /tmp"
  actuator --- ls -la /tmp

  # With timeout (30 seconds)
  actuator -t 30 "sleep 60"
  actuator -t 30 --- sleep 60

  # Stream real-time status
  actuator -s --- make build

  # Write mode: command stdout passes through, JSON to stderr
  actuator -w --- echo hello > /tmp/out   # /tmp/out gets "hello", JSON on stderr
  actuator -w -c "ls -la > /tmp/listing"  # file write, JSON on stderr

  # Suppress command output, keep metadata only
  actuator -q "git diff --staged ./"
  actuator --quiet --plain "npm test"

  # Async execution
  actuator -a --- npm install
  actuator -a -j my_build --- npm run build       # Custom job ID
  actuator --poll 1738800000_12345                 # Single poll
  actuator -p 1738800000_12345 -s                  # Continuous polling with heartbeat
  actuator --terminate 1738800000_12345

  # Commands with shell metacharacters (;, |, &&)
  actuator --stdin <<< 'while :; do echo tick; sleep 1; done'
  echo 'ls -la | grep txt' | actuator
  actuator -t 5 --stdin <<< 'while :; do echo tick; sleep 1; done'

  # Multi-line commands using heredoc
  cat << 'HEREDOC' | actuator
    ls -la
    echo "---"
    pwd
  HEREDOC
  
  # With timeout
  cat << 'HEREDOC' | actuator -t 30
    sleep 5
    echo "done"
  HEREDOC
  
  # Async multi-line
  cat << 'HEREDOC' | actuator -a
    npm install
    npm run build
  HEREDOC

  # Shell integration (add to ~/.zshrc or ~/.bashrc)
  eval "$(actuator --init)"          # Enables: actuator cd ~/git

  # Job management
  actuator --list                    # JSON output
  actuator --list --plain            # Formatted table
  actuator -l -n 20                  # Show 20 most recent jobs
  actuator -l -n 50 --plain          # Show 50 most recent in table format
  actuator --terminate-all
  actuator --cleanup

ENVIRONMENT:
  ACTUATOR_JOBS_DIR        Job storage directory (default: /tmp/actuator-jobs)
  ACTUATOR_STATUS_INTERVAL Status update interval in seconds (default: 2)

OUTPUT:
  All output is JSON-structured for AI consumption.
  Use --plain for human-readable plain text output.
EOF
}

# =============================================================================
# Shell Init (eval "$(actuator --init)")
# =============================================================================

emit_shell_init() {
  cat <<'SHELL_INIT'
# Actuator shell wrapper — enables commands that affect the current shell
# (cd, pushd, popd) to work through actuator.
# Add to your shell profile: eval "$(actuator --init)"
actuator() {
  # Parse args to extract the command portion
  # Supports: actuator cd /tmp        → separate args
  #           actuator --- cd /tmp    → separator mode
  #           actuator -c "cd /tmp"   → flag mode
  #           actuator "cd /tmp"      → single string
  local _cmd_args=() _cmd_str="" _first_word="" _has_flags=false
  local _skip_next=false _collecting=false _via_flag=false

  for _arg in "$@"; do
    if [[ "$_skip_next" == "true" ]]; then
      _skip_next=false
      continue
    fi
    if [[ "$_collecting" == "true" ]]; then
      _cmd_args+=("$_arg")
      [[ -z "$_first_word" ]] && _first_word="${_arg%% *}"
      continue
    fi
    case "$_arg" in
      -c|--command)
        _via_flag=true; _skip_next=true
        local _next=false
        for _a in "$@"; do
          if [[ "$_next" == "true" ]]; then _cmd_str="$_a"; break; fi
          [[ "$_a" == "$_arg" ]] && _next=true
        done
        _first_word="${_cmd_str%% *}"
        ;;
      ---) _collecting=true ;;
      -t|--timeout|-j|--job-id|-p|--poll|-k|--terminate) _skip_next=true; _has_flags=true ;;
      -a|--async|-s|--stream|-w|--write|-q|--quiet|--plain|-l|--list|--cleanup|--terminate-all|--stdin)
        _has_flags=true ;;
      -*) ;;
      *)
        _cmd_args+=("$_arg")
        [[ -z "$_first_word" ]] && _first_word="${_arg%% *}"
        _collecting=true
        ;;
    esac
  done

  # Handle cd/pushd/popd: apply directory change to current shell
  case "$_first_word" in
    cd|pushd|popd)
      if [[ "$_has_flags" == "false" ]]; then
        # No actuator flags: pure shell operation, don't call actuator
        if [[ "$_via_flag" == "true" ]]; then
          eval "$_cmd_str" || return $?
        elif [[ ${#_cmd_args[@]} -eq 1 && "${_cmd_args[*]}" == *" "* ]]; then
          eval "${_cmd_args[*]}" || return $?
        else
          builtin "${_cmd_args[@]}" || return $?
        fi
        return 0
      fi

      # Has actuator flags (-a, -s, etc.): pass through first, then cd locally
      # MUST call actuator before cd, so the subprocess inherits the original cwd
      command actuator "$@"
      local _rc=$?

      local _dir=""
      if [[ "$_via_flag" == "true" || ( ${#_cmd_args[@]} -eq 1 && "${_cmd_args[*]}" == *" "* ) ]]; then
        local _str="${_cmd_str:-${_cmd_args[*]}}"
        _str="${_str#cd }"
        _str="${_str#pushd }"
        _dir="${_str%%&&*}"
        _dir="${_dir%%;*}"
        _dir="${_dir%%||*}"
        _dir="${_dir%%|*}"
        _dir="${_dir%% }"
      else
        local _rest="${_cmd_args[*]}"
        _dir="${_rest#* }"
        [[ "$_dir" == "$_rest" ]] && _dir=""
      fi

      # Best-effort cd in current shell after actuator returns
      if [[ -n "$_dir" ]]; then
        builtin cd "$_dir" 2>/dev/null || true
      else
        builtin cd 2>/dev/null || true
      fi
      return $_rc
      ;;
  esac

  # Delegate to the real actuator binary
  command actuator "$@"
}
SHELL_INIT
}

# =============================================================================
# Main
# =============================================================================

main() {
  local command="" mode="sync" timeout="$DEFAULT_TIMEOUT"
  local stream="false" plain="false" use_tty="false" quiet="false" write_mode="false"
  local poll_id="" terminate_id="" terminate_signal="TERM" list_jobs_flag="false"
  local custom_job_id="" list_limit=""

  # Get execution sequence number (global for all functions)
  EXEC_SEQUENCE=$(get_next_sequence)
  EXEC_CWD=$(pwd)

  # Auto-detect piped stdin when no args
  if [[ $# -eq 0 ]]; then
    if [[ ! -t 0 ]]; then
      command=$(cat)
    else
      usage
      exit 0
    fi
  fi

  # Auto-enable TTY if stdin is a terminal (nothing piped)
  # TTY mode runs commands in the FOREGROUND so they get real terminal access.
  # This allows interactive commands (ssh) and isatty-dependent commands (cdiff)
  # to work correctly. Output goes directly to the user's terminal.
  if [[ -t 0 && "$use_tty" == "false" ]]; then
    use_tty="true"
  fi

  # First pass: collect all flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -c|--command)
        command="$2"; shift 2 ;;
      -a|--async)
        mode="async"; shift ;;
      -j|--job-id)
        custom_job_id="$2"; shift 2 ;;
      -s|--stream)
        stream="true"; shift ;;
      -t|--timeout)
        timeout="$2"; shift 2 ;;
      -p|--poll)
        poll_id="$2"; shift 2 ;;
      -k|--terminate)
        terminate_id="$2"
        shift 2
        [[ $# -gt 0 && "$1" != -* ]] && { terminate_signal="$1"; shift; }
        ;;
      --stdin)
        command=$(cat); shift ;;
      --plain)
        plain="true"; shift ;;
      -w|--write)
        write_mode="true"; shift ;;
      -q|--quiet)
        quiet="true"; shift ;;
      -v|--version)
        printf '{"version": "%s"}\n' "$VERSION"; exit 0 ;;
      --init)
        emit_shell_init; exit 0 ;;
      -h|--help)
        usage; exit 0 ;;
      -l|--list)
        list_jobs_flag="true"; shift ;;
      -n|--limit)
        list_limit="$2"; shift 2 ;;
      --terminate-all)
        terminate_all_jobs; exit 0 ;;
      --cleanup)
        cleanup_jobs || true  # Ignore any errors from cleanup
        wait  # Wait for any remaining background jobs
        exit 0 ;;
      ---)
        shift
        if [[ $# -eq 1 ]]; then
          command="$1"  # Single arg: preserve as-is (supports "cmd1 && cmd2")
        else
          command=$(printf '%q ' "$@")  # Multiple args: quote each separately
        fi
        break ;;
      -*)
        if [[ "$plain" == "true" ]]; then
          printf '%s\n' "------ Error ------" >&2
          printf 'Unknown option: %s\n' "$1" >&2
        else
          printf '{"status":"error","error":"Unknown option: %s"}\n' "$1" >&2
        fi
        exit 1 ;;
      *)
        command="$*"; break ;;
    esac
  done

  # Disable TTY when streaming is requested - streaming requires polling mode
  # to emit heartbeat events. This ensures -s flag always gets heartbeat support.
  if [[ "$stream" == "true" ]]; then
    use_tty="false"
  fi

  # Set global mode flags for json helper functions
  PLAIN_MODE="$plain"
  QUIET_MODE="$quiet"
  WRITE_MODE="$write_mode"

  # Handle deferred actions
  if [[ "$list_jobs_flag" == "true" ]]; then
    list_jobs "$plain" "$list_limit"
    exit 0
  fi

  # Handle job operations
  if [[ -n "$poll_id" ]]; then
    if [[ "$stream" == "true" ]]; then
      poll_job_stream "$poll_id" "$plain"
    else
      poll_job "$poll_id" "$plain"
    fi
    exit $?
  fi

  if [[ -n "$terminate_id" ]]; then
    terminate_job "$terminate_id" "$terminate_signal"
    exit $?
  fi

  # Validate command
  if [[ -z "$command" ]]; then
    if [[ "$plain" == "true" ]]; then
      printf '%s\n' "------ Error ------" >&2
      printf 'No command specified. Use -h for help.\n' >&2
    else
      printf '{"status":"error","error":"No command specified. Use -h for help."}\n' >&2
    fi
    exit 1
  fi

  # Execute
  case "$mode" in
    sync)
      execute_sync "$command" "$timeout" "$stream" "$plain" "$use_tty" "$quiet" "$write_mode"
      ;;
    async)
      execute_async "$command" "$timeout" "$plain" "$use_tty" "$quiet" "$custom_job_id" "$write_mode"
      ;;
  esac
}

main "$@"
