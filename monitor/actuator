#!/usr/bin/env bash
# =============================================================================
# Universal CLI Execution Tool - ACTUATOR
# Version: 1.0.0 (MVP - Phase 1)
# =============================================================================
set -euo pipefail

readonly VERSION="1.0.1"
readonly JOBS_DIR="${ACTUATOR_JOBS_DIR:-/tmp/actuator-jobs}"
readonly SEQUENCE_FILE="${JOBS_DIR}/.sequence"
readonly DEFAULT_TIMEOUT=0
readonly STATUS_INTERVAL="${ACTUATOR_STATUS_INTERVAL:-2}"

# Global execution sequence (set in main before any command execution)
EXEC_SEQUENCE=0

# =============================================================================
# Sequence Counter (execution order tracking)
# =============================================================================

get_next_sequence() {
  init_jobs_dir
  local current=0
  if [[ -f "$SEQUENCE_FILE" ]]; then
    current=$(cat "$SEQUENCE_FILE" 2>/dev/null || echo 0)
  fi
  local next=$((current + 1))
  printf '%d' "$next" > "$SEQUENCE_FILE" 2>/dev/null || true
  printf '%d' "$next"
}

# =============================================================================
# JSON Helpers (no jq dependency)
# =============================================================================

json_escape() {
  local str="$1"
  str="${str//\\/\\\\}"
  str="${str//\"/\\\"}"
  str="${str//$'\n'/\\n}"
  str="${str//$'\r'/\\r}"
  str="${str//$'\t'/\\t}"
  printf '%s' "$str"
}

json_output() {
  local status="$1" exit_code="$2" command="$3"
  local stdout_data="$4" stderr_data="$5"
  local start_time="$6" end_time="$7"
  local job_id="${8:-}" pid="${9:-}" sequence="${10:-0}"
  local duration=0

  if [[ -n "$start_time" && -n "$end_time" ]]; then
    duration=$(( end_time - start_time ))
  fi

  cat <<ENDJSON
{
  "version": ${sequence},
  "status": "$(json_escape "$status")",
  "exit_code": ${exit_code},
  "command": "$(json_escape "$command")",
  "stdout": "$(json_escape "$stdout_data")",
  "stderr": "$(json_escape "$stderr_data")",
  "metadata": {
    "start_time": ${start_time:-0},
    "end_time": ${end_time:-0},
    "duration_seconds": ${duration},
    "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  }$(if [[ -n "$job_id" ]]; then printf ',\n  "job": {\n    "id": "%s",\n    "pid": %s\n  }' "$job_id" "${pid:-0}"; fi)
}
ENDJSON
}

plain_output() {
  local status="$1" exit_code="$2" command="$3"
  local stdout_data="$4" stderr_data="$5"
  local start_time="$6" end_time="$7"
  local duration=0

  if [[ -n "$start_time" && -n "$end_time" ]]; then
    duration=$(( end_time - start_time ))
  fi

  printf '=== Command Execution Result ===\n'
  printf 'Status: %s\n' "$status"
  printf 'Exit Code: %d\n' "$exit_code"
  printf 'Duration: %d seconds\n' "$duration"

  if [[ -n "$stdout_data" ]]; then
    printf '\n--- Standard Output ---\n%s\n' "$stdout_data"
  fi

  if [[ -n "$stderr_data" ]]; then
    printf '\n--- Standard Error ---\n%s\n' "$stderr_data"
  fi
}

json_status_update() {
  local status="$1" job_id="$2" message="${3:-}"
  cat <<ENDJSON
{"event": "status_update", "status": "$(json_escape "$status")", "job_id": "$(json_escape "$job_id")", "message": "$(json_escape "$message")", "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"}
ENDJSON
}

json_stream_line() {
  local stream="$1" data="$2"
  printf '{"event":"%s","data":"%s","timestamp":"%s"}\n' \
    "$stream" "$(json_escape "$data")" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}

# =============================================================================
# Job Management
# =============================================================================

init_jobs_dir() {
  mkdir -p "$JOBS_DIR"
}

generate_job_id() {
  printf '%s_%s' "$(date +%s)" "$$"
}

save_job_state() {
  local job_id="$1" pid="$2" command="$3" status="$4" start_time="$5"
  local job_file="${JOBS_DIR}/${job_id}.job"
  cat > "$job_file" <<EOF
JOB_ID='${job_id}'
PID='${pid}'
COMMAND='${command//\'/\'\\\'\'}'
STATUS='${status}'
START_TIME='${start_time}'
STDOUT_FILE='${JOBS_DIR}/${job_id}.stdout'
STDERR_FILE='${JOBS_DIR}/${job_id}.stderr'
EOF
}

update_job_status() {
  local job_id="$1" status="$2" exit_code="${3:-}"
  local job_file="${JOBS_DIR}/${job_id}.job"
  [[ -f "$job_file" ]] || return 0  # Don't fail if file doesn't exist yet

  if command -v sed &>/dev/null; then
    sed -i.bak "s/^STATUS=.*/STATUS='${status}'/" "$job_file" 2>/dev/null || \
      sed -i '' "s/^STATUS=.*/STATUS='${status}'/" "$job_file" || true
    rm -f "${job_file}.bak"
  fi

  if [[ -n "$exit_code" ]]; then
    echo "EXIT_CODE='${exit_code}'" >> "$job_file"
    echo "END_TIME='$(date +%s)'" >> "$job_file"
  fi
}

load_job_state() {
  local job_id="$1"
  local job_file="${JOBS_DIR}/${job_id}.job"
  [[ -f "$job_file" ]] || { echo "Job not found: ${job_id}" >&2; return 1; }
  # shellcheck disable=SC1090
  source "$job_file"
}

# =============================================================================
# Signal Handling & Cleanup
# =============================================================================

kill_child() {
  local pid="$1" signal="${2:-TERM}"
  kill -"$signal" "$pid" 2>/dev/null || true
}

# Global state for signal handler (avoids quote escaping issues in trap strings)
TRAP_CMD_PID=""
TRAP_STDOUT_FILE=""
TRAP_STDERR_FILE=""
TRAP_COMMAND=""
TRAP_START_TIME=""
TIMEOUT_MONITOR_PID=""

handle_signal() {
  local signal_name="$1"
  local exit_code

  case "$signal_name" in
    INT)  exit_code=130 ;;
    TERM) exit_code=143 ;;
    *)    exit_code=1 ;;
  esac

  # Kill child process immediately
  if [[ -n "$TRAP_CMD_PID" ]]; then
    kill_child "$TRAP_CMD_PID" KILL
    wait "$TRAP_CMD_PID" 2>/dev/null || true
  fi

  # Kill timeout monitor if active
  if [[ -n "${TIMEOUT_MONITOR_PID:-}" ]]; then
    kill_child "$TIMEOUT_MONITOR_PID" KILL
    wait "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
  fi

  local end_time
  end_time=$(date +%s)

  # Capture whatever output was produced before interruption
  local stdout_data="" stderr_data=""
  [[ -f "$TRAP_STDOUT_FILE" ]] && stdout_data=$(cat "$TRAP_STDOUT_FILE" 2>/dev/null || true)
  [[ -f "$TRAP_STDERR_FILE" ]] && stderr_data=$(cat "$TRAP_STDERR_FILE" 2>/dev/null || true)

  rm -f "$TRAP_STDOUT_FILE" "$TRAP_STDERR_FILE"

  json_output "interrupted" "$exit_code" "$TRAP_COMMAND" "$stdout_data" "$stderr_data" "$TRAP_START_TIME" "$end_time" "" "" "$EXEC_SEQUENCE"
  exit "$exit_code"
}

# =============================================================================
# Timeout Monitor
# =============================================================================

start_timeout_monitor() {
  local pid="$1" timeout="$2"

  {
    sleep "$timeout" 2>/dev/null
    if kill -0 "$pid" 2>/dev/null; then
      kill_child "$pid" TERM
      sleep 2
      kill -0 "$pid" 2>/dev/null && kill_child "$pid" KILL
    fi
  } &
  TIMEOUT_MONITOR_PID=$!
}

# =============================================================================
# Core Execution: Synchronous
# =============================================================================

execute_sync() {
  local command="$1"
  local timeout="${2:-$DEFAULT_TIMEOUT}"
  local stream_output="${3:-false}"
  local plain="${4:-false}"
  local use_tty="${5:-false}"
  local quiet="${6:-false}"

  local stdout_file stderr_file start_time end_time exit_code=0
  stdout_file=$(mktemp)
  stderr_file=$(mktemp)
  start_time=$(date +%s)

  if [[ "$stream_output" == "true" ]]; then
    json_status_update "started" "sync" "Executing: ${command}"
  fi

  # Foreground mode: run command directly (not backgrounded) to avoid
  # SIGTTIN/SIGTTOU signals that suspend backgrounded terminal processes.
  # Uses tee to BOTH display output on terminal AND capture to files.
  # Stdin stays as-is so commands like cdiff detect isatty(stdin) for VCS mode
  # and interactive commands like ssh get terminal input.
  if [[ "$use_tty" == "true" ]]; then
    # TTY Mode: Direct foreground execution OR polling for streaming with heartbeat
    if [[ "$stream_output" == "true" ]]; then
      # Streaming + TTY: Use polling loop to emit heartbeat events while maintaining TTY output
      # Background command but keep output flowing to terminal and files
      bash -c "$command" < /dev/stdin > "$stdout_file" 2> "$stderr_file" &
      local cmd_pid=$!

      # Set global state for signal handler
      TRAP_CMD_PID="$cmd_pid"
      TRAP_STDOUT_FILE="$stdout_file"
      TRAP_STDERR_FILE="$stderr_file"
      TRAP_COMMAND="$command"
      TRAP_START_TIME="$start_time"

      trap 'handle_signal INT' INT
      trap 'handle_signal TERM' TERM

      # Start timeout monitor if configured
      TIMEOUT_MONITOR_PID=""
      if [[ "$timeout" -gt 0 ]]; then
        start_timeout_monitor "$cmd_pid" "$timeout"
      fi

      # Also display output to terminal in real-time via tee
      if [[ "$quiet" != "true" ]]; then
        # Continuously tail output to terminal while polling for events
        tail -f "$stdout_file" 2>/dev/null &
        local tail_pid=$!
        tail -f "$stderr_file" 2>/dev/null >&2 &
        local tail_err_pid=$!
      fi

      # Polling loop with heartbeat events
      local stdout_lines=0 stderr_lines=0
      local poll_count=0
      local heartbeat_every=$(( ${STATUS_INTERVAL%.*} * 5 ))
      [[ "$heartbeat_every" -lt 5 ]] && heartbeat_every=5

      while kill -0 "$cmd_pid" 2>/dev/null; do
        local had_output=false

        # Emit new stdout lines
        local current_out
        current_out=$(wc -l < "$stdout_file" 2>/dev/null | tr -d ' ')
        if [[ "${current_out:-0}" -gt "$stdout_lines" ]]; then
          tail -n +"$((stdout_lines + 1))" "$stdout_file" 2>/dev/null | while IFS= read -r line; do
            json_stream_line "stdout" "$line"
          done
          stdout_lines="$current_out"
          had_output=true
        fi

        # Emit new stderr lines
        local current_err
        current_err=$(wc -l < "$stderr_file" 2>/dev/null | tr -d ' ')
        if [[ "${current_err:-0}" -gt "$stderr_lines" ]]; then
          tail -n +"$((stderr_lines + 1))" "$stderr_file" 2>/dev/null | while IFS= read -r line; do
            json_stream_line "stderr" "$line"
          done
          stderr_lines="$current_err"
          had_output=true
        fi

        # Heartbeat: emit status even when no new output
        (( poll_count++ )) || true
        if [[ "$had_output" == "false" && $(( poll_count % heartbeat_every )) -eq 0 ]]; then
          local elapsed=$(( $(date +%s) - start_time ))
          local out_bytes err_bytes
          out_bytes=$(wc -c < "$stdout_file" 2>/dev/null | tr -d ' ')
          err_bytes=$(wc -c < "$stderr_file" 2>/dev/null | tr -d ' ')
          printf '{"event":"heartbeat","status":"running","elapsed_seconds":%d,"stdout_bytes":%s,"stderr_bytes":%s,"pid":%d,"timestamp":"%s"}\n' \
            "$elapsed" "${out_bytes:-0}" "${err_bytes:-0}" "$cmd_pid" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        fi

        sleep 0.2 &
        wait $! 2>/dev/null || true
      done

      # Clean up tail processes if used
      if [[ "$quiet" != "true" ]]; then
        kill "$tail_pid" "$tail_err_pid" 2>/dev/null || true
        wait "$tail_pid" "$tail_err_pid" 2>/dev/null || true
      fi

      # Flush any remaining lines after process exits
      tail -n +"$((stdout_lines + 1))" "$stdout_file" 2>/dev/null | while IFS= read -r line; do
        json_stream_line "stdout" "$line"
      done
      tail -n +"$((stderr_lines + 1))" "$stderr_file" 2>/dev/null | while IFS= read -r line; do
        json_stream_line "stderr" "$line"
      done

      wait "$cmd_pid" 2>/dev/null || exit_code=$?
      end_time=$(date +%s)

      # Kill timeout monitor if active
      if [[ -n "$TIMEOUT_MONITOR_PID" ]]; then
        kill "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
        wait "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
      fi

      local status="completed"
      if [[ "$timeout" -gt 0 && ( "$exit_code" -eq 137 || "$exit_code" -eq 143 ) ]]; then
        status="timeout"
      elif [[ "$exit_code" -ne 0 ]]; then
        status="failed"
      fi

      local stdout_data stderr_data
      stdout_data=$(cat "$stdout_file" 2>/dev/null || true)
      stderr_data=$(cat "$stderr_file" 2>/dev/null || true)
      rm -f "$stdout_file" "$stderr_file"

      if [[ "$plain" == "true" ]]; then
        plain_output "$status" "$exit_code" "$command" "$stdout_data" "$stderr_data" "$start_time" "$end_time"
      else
        json_output "$status" "$exit_code" "$command" "$stdout_data" "$stderr_data" "$start_time" "$end_time" "" "" "$EXEC_SEQUENCE"
      fi
      return
    fi

    # Non-streaming TTY: Direct foreground execution (original behavior)
    if [[ "$timeout" -gt 0 ]]; then
      start_timeout_monitor "$$" "$timeout"
    fi

    if [[ "$quiet" == "true" ]]; then
      # Quiet mode: suppress terminal output entirely
      bash -c "$command" > "$stdout_file" 2> "$stderr_file" || exit_code=$?
    else
      # Normal mode: display to terminal while capturing
      bash -c "$command" > >(tee "$stdout_file") 2> >(tee "$stderr_file" >&2) || exit_code=$?
    fi
    end_time=$(date +%s)

    if [[ -n "$TIMEOUT_MONITOR_PID" ]]; then
      kill "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
      wait "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
    fi

    # Allow tee processes to flush
    wait 2>/dev/null || true

    local status="completed"
    if [[ "$timeout" -gt 0 && ( "$exit_code" -eq 137 || "$exit_code" -eq 143 ) ]]; then
      status="timeout"
    elif [[ "$exit_code" -ne 0 ]]; then
      status="failed"
    fi

    local stdout_data stderr_data
    stdout_data=$(cat "$stdout_file" 2>/dev/null || true)
    stderr_data=$(cat "$stderr_file" 2>/dev/null || true)
    rm -f "$stdout_file" "$stderr_file"

    if [[ "$plain" == "true" ]]; then
      plain_output "$status" "$exit_code" "$command" "$stdout_data" "$stderr_data" "$start_time" "$end_time"
    else
      json_output "$status" "$exit_code" "$command" "$stdout_data" "$stderr_data" "$start_time" "$end_time" "" "" "$EXEC_SEQUENCE"
    fi
    return
  fi

  # Non-TTY mode: background with output capture
  # This path is used when stdin is piped (not a terminal).
  # NOTE: < /dev/stdin preserves piped input to child process
  bash -c "$command" < /dev/stdin > "$stdout_file" 2> "$stderr_file" &
  local cmd_pid=$!

  # Set global state for signal handler
  TRAP_CMD_PID="$cmd_pid"
  TRAP_STDOUT_FILE="$stdout_file"
  TRAP_STDERR_FILE="$stderr_file"
  TRAP_COMMAND="$command"
  TRAP_START_TIME="$start_time"

  trap 'handle_signal INT' INT
  trap 'handle_signal TERM' TERM

  # Start timeout monitor if configured
  TIMEOUT_MONITOR_PID=""
  if [[ "$timeout" -gt 0 ]]; then
    start_timeout_monitor "$cmd_pid" "$timeout"
  fi

  # Wait for command with signal-responsive loop
  if [[ "$stream_output" == "true" ]]; then
    # Poll for new lines and emit as JSON events (no background processes to leak)
    local stdout_lines=0 stderr_lines=0
    local poll_count=0
    local heartbeat_every=$(( ${STATUS_INTERVAL%.*} * 5 ))  # heartbeat every N polls
    [[ "$heartbeat_every" -lt 5 ]] && heartbeat_every=5

    while kill -0 "$cmd_pid" 2>/dev/null; do
      local had_output=false

      # Emit new stdout lines
      local current_out
      current_out=$(wc -l < "$stdout_file" 2>/dev/null | tr -d ' ')
      if [[ "${current_out:-0}" -gt "$stdout_lines" ]]; then
        tail -n +"$((stdout_lines + 1))" "$stdout_file" 2>/dev/null | while IFS= read -r line; do
          json_stream_line "stdout" "$line"
        done
        stdout_lines="$current_out"
        had_output=true
      fi

      # Emit new stderr lines
      local current_err
      current_err=$(wc -l < "$stderr_file" 2>/dev/null | tr -d ' ')
      if [[ "${current_err:-0}" -gt "$stderr_lines" ]]; then
        tail -n +"$((stderr_lines + 1))" "$stderr_file" 2>/dev/null | while IFS= read -r line; do
          json_stream_line "stderr" "$line"
        done
        stderr_lines="$current_err"
        had_output=true
      fi

      # Heartbeat: emit status even when no new output
      (( poll_count++ )) || true
      if [[ "$had_output" == "false" && $(( poll_count % heartbeat_every )) -eq 0 ]]; then
        local elapsed=$(( $(date +%s) - start_time ))
        local out_bytes err_bytes
        out_bytes=$(wc -c < "$stdout_file" 2>/dev/null | tr -d ' ')
        err_bytes=$(wc -c < "$stderr_file" 2>/dev/null | tr -d ' ')
        printf '{"event":"heartbeat","status":"running","elapsed_seconds":%d,"stdout_bytes":%s,"stderr_bytes":%s,"pid":%d,"timestamp":"%s"}\n' \
          "$elapsed" "${out_bytes:-0}" "${err_bytes:-0}" "$cmd_pid" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
      fi

      sleep 0.2 &
      wait $! 2>/dev/null || true
    done

    # Flush any remaining lines after process exits
    tail -n +"$((stdout_lines + 1))" "$stdout_file" 2>/dev/null | while IFS= read -r line; do
      json_stream_line "stdout" "$line"
    done
    tail -n +"$((stderr_lines + 1))" "$stderr_file" 2>/dev/null | while IFS= read -r line; do
      json_stream_line "stderr" "$line"
    done
  else
    while kill -0 "$cmd_pid" 2>/dev/null; do
      sleep 0.1 &
      wait $! 2>/dev/null || true
    done
  fi

  wait "$cmd_pid" 2>/dev/null || exit_code=$?
  end_time=$(date +%s)

  # Kill timeout monitor if active
  if [[ -n "$TIMEOUT_MONITOR_PID" ]]; then
    kill "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
    wait "$TIMEOUT_MONITOR_PID" 2>/dev/null || true
  fi

  # Check if killed by timeout (SIGTERM=143, SIGKILL=137)
  local status="completed"
  if [[ "$timeout" -gt 0 && ( "$exit_code" -eq 137 || "$exit_code" -eq 143 ) ]]; then
    status="timeout"
  elif [[ "$exit_code" -ne 0 ]]; then
    status="failed"
  fi

  local stdout_data stderr_data
  stdout_data=$(cat "$stdout_file" 2>/dev/null || true)
  stderr_data=$(cat "$stderr_file" 2>/dev/null || true)

  rm -f "$stdout_file" "$stderr_file"

  if [[ "$plain" == "true" ]]; then
    plain_output "$status" "$exit_code" "$command" "$stdout_data" "$stderr_data" "$start_time" "$end_time"
  else
    json_output "$status" "$exit_code" "$command" "$stdout_data" "$stderr_data" "$start_time" "$end_time" "" "" "$EXEC_SEQUENCE"
  fi
}

# =============================================================================
# Core Execution: Asynchronous
# =============================================================================

execute_async() {
  local command="$1"
  local timeout="${2:-$DEFAULT_TIMEOUT}"
  local plain="${3:-false}"
  local use_tty="${4:-false}"
  local quiet="${5:-false}"

  init_jobs_dir
  local job_id
  job_id=$(generate_job_id)
  local stdout_file="${JOBS_DIR}/${job_id}.stdout"
  local stderr_file="${JOBS_DIR}/${job_id}.stderr"
  local start_time
  start_time=$(date +%s)

  # Save job state BEFORE launching background process
  save_job_state "$job_id" "0" "$command" "running" "$start_time"

  # Launch command in background subshell
  # NOTE: < /dev/stdin preserves piped input to child process
  # For TTY mode: pass through directly (no output capture)
  (
    local exit_code=0
    if [[ "$use_tty" == "true" ]]; then
      eval "$command" || exit_code=$?
    else
      eval "$command" < /dev/stdin > "$stdout_file" 2> "$stderr_file" || exit_code=$?
    fi

    # Update job state on completion
    if [[ "$exit_code" -eq 0 ]]; then
      update_job_status "$job_id" "completed" "$exit_code"
    else
      update_job_status "$job_id" "failed" "$exit_code"
    fi
  ) &
  local cmd_pid=$!

  # Update with actual process ID
  sed -i '' "s/^PID=.*/PID='${cmd_pid}'/" "${JOBS_DIR}/${job_id}.job"

  # Start timeout monitor if configured
  if [[ "$timeout" -gt 0 ]]; then
    start_timeout_monitor "$cmd_pid" "$timeout"
  fi

  json_output "running" "-1" "$command" "" "" "$start_time" "" "$job_id" "$cmd_pid" "$EXEC_SEQUENCE" "$quiet"
}

# =============================================================================
# Job Operations
# =============================================================================

poll_job() {
  local job_id="$1"
  local JOB_ID PID COMMAND STATUS START_TIME STDOUT_FILE STDERR_FILE EXIT_CODE END_TIME

  load_job_state "$job_id" || {
    printf '{"error": "Job not found", "job_id": "%s"}\n' "$job_id"
    return 1
  }

  # Check if process is still running
  if [[ "$STATUS" == "running" ]] && ! kill -0 "$PID" 2>/dev/null; then
    wait "$PID" 2>/dev/null
    local actual_exit=$?
    if [[ "$actual_exit" -eq 0 ]]; then
      STATUS="completed"
    else
      STATUS="failed"
    fi
    update_job_status "$job_id" "$STATUS" "$actual_exit"
    EXIT_CODE="$actual_exit"
    END_TIME=$(date +%s)
  fi

  local stdout_data="" stderr_data=""
  [[ -f "$STDOUT_FILE" ]] && stdout_data=$(cat "$STDOUT_FILE" 2>/dev/null || true)
  [[ -f "$STDERR_FILE" ]] && stderr_data=$(cat "$STDERR_FILE" 2>/dev/null || true)

  json_output "$STATUS" "${EXIT_CODE:--1}" "$COMMAND" "$stdout_data" "$stderr_data" \
    "$START_TIME" "${END_TIME:-}" "$JOB_ID" "$PID" "$EXEC_SEQUENCE"
}

poll_job_stream() {
  local job_id="$1"
  local JOB_ID PID COMMAND STATUS START_TIME STDOUT_FILE STDERR_FILE EXIT_CODE END_TIME
  local poll_count=0
  local heartbeat_every=$(( ${STATUS_INTERVAL%.*} * 5 ))
  [[ "$heartbeat_every" -lt 5 ]] && heartbeat_every=5

  load_job_state "$job_id" || {
    printf '{"error": "Job not found", "job_id": "%s"}\n' "$job_id"
    return 1
  }

  json_status_update "monitoring" "$job_id" "Monitoring job: $COMMAND"

  local stdout_lines=0 stderr_lines=0
  local initial_status="$STATUS"

  # Polling loop with heartbeat events
  while true; do
    # Reload job state
    load_job_state "$job_id" || break

    # Check if process is still running
    if [[ "$STATUS" == "running" ]] && ! kill -0 "$PID" 2>/dev/null; then
      wait "$PID" 2>/dev/null
      local actual_exit=$?
      if [[ "$actual_exit" -eq 0 ]]; then
        STATUS="completed"
      else
        STATUS="failed"
      fi
      update_job_status "$job_id" "$STATUS" "$actual_exit"
      EXIT_CODE="$actual_exit"
      END_TIME=$(date +%s)
    fi

    local had_output=false
    local lines_to_emit

    # Emit new stdout lines
    if [[ -f "$STDOUT_FILE" ]]; then
      local current_out
      current_out=$(wc -l < "$STDOUT_FILE" 2>/dev/null | tr -d ' ')
      if [[ "${current_out:-0}" -gt "$stdout_lines" ]]; then
        lines_to_emit=$(tail -n +"$((stdout_lines + 1))" "$STDOUT_FILE" 2>/dev/null)
        while IFS= read -r line; do
          json_stream_line "stdout" "$line"
        done <<< "$lines_to_emit"
        stdout_lines="$current_out"
        had_output=true
      fi
    fi

    # Emit new stderr lines
    if [[ -f "$STDERR_FILE" ]]; then
      local current_err
      current_err=$(wc -l < "$STDERR_FILE" 2>/dev/null | tr -d ' ')
      if [[ "${current_err:-0}" -gt "$stderr_lines" ]]; then
        lines_to_emit=$(tail -n +"$((stderr_lines + 1))" "$STDERR_FILE" 2>/dev/null)
        while IFS= read -r line; do
          json_stream_line "stderr" "$line"
        done <<< "$lines_to_emit"
        stderr_lines="$current_err"
        had_output=true
      fi
    fi

    # Heartbeat: emit status even when no new output
    (( poll_count++ )) || true
    if [[ "$had_output" == "false" && $(( poll_count % heartbeat_every )) -eq 0 ]]; then
      local out_bytes=0 err_bytes=0
      [[ -f "$STDOUT_FILE" ]] && out_bytes=$(wc -c < "$STDOUT_FILE" 2>/dev/null | tr -d ' ')
      [[ -f "$STDERR_FILE" ]] && err_bytes=$(wc -c < "$STDERR_FILE" 2>/dev/null | tr -d ' ')
      printf '{"event":"heartbeat","status":"%s","job_id":"%s","pid":%d,"stdout_bytes":%s,"stderr_bytes":%s,"timestamp":"%s"}\n' \
        "$STATUS" "$job_id" "$PID" "${out_bytes:-0}" "${err_bytes:-0}" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    fi

    # Break if job is done
    if [[ "$STATUS" != "running" ]]; then
      # Emit final state
      local stdout_data="" stderr_data=""
      [[ -f "$STDOUT_FILE" ]] && stdout_data=$(cat "$STDOUT_FILE" 2>/dev/null || true)
      [[ -f "$STDERR_FILE" ]] && stderr_data=$(cat "$STDERR_FILE" 2>/dev/null || true)
      json_output "$STATUS" "${EXIT_CODE:--1}" "$COMMAND" "$stdout_data" "$stderr_data" \
        "$START_TIME" "${END_TIME:-}" "$JOB_ID" "$PID" "$EXEC_SEQUENCE"
      break
    fi

    sleep 0.2 &
    wait $! 2>/dev/null || true
  done
}

terminate_job() {
  local job_id="$1"
  local signal="${2:-TERM}"
  local JOB_ID PID COMMAND STATUS START_TIME STDOUT_FILE STDERR_FILE

  load_job_state "$job_id" || {
    printf '{"error": "Job not found", "job_id": "%s"}\n' "$job_id"
    return 1
  }

  if kill -0 "$PID" 2>/dev/null; then
    kill -"$signal" "$PID" 2>/dev/null
    sleep 1
    if kill -0 "$PID" 2>/dev/null && [[ "$signal" != "KILL" ]]; then
      kill -KILL "$PID" 2>/dev/null
    fi
    update_job_status "$job_id" "terminated" "143"
    json_status_update "terminated" "$job_id" "Process terminated with signal ${signal}"
  else
    json_status_update "already_stopped" "$job_id" "Process is not running"
  fi
}

terminate_all_jobs() {
  init_jobs_dir
  local terminated_count=0
  local first=true
  printf '{"terminated_jobs": ['

  for job_file in "${JOBS_DIR}"/*.job; do
    [[ -f "$job_file" ]] || continue

    local JOB_ID="" PID="" COMMAND="" STATUS=""
    # shellcheck disable=SC1090
    source "$job_file" || continue

    # Only terminate if running
    if [[ "$STATUS" == "running" ]] && kill -0 "$PID" 2>/dev/null; then
      kill -TERM "$PID" 2>/dev/null || true
      sleep 0.5
      kill -0 "$PID" 2>/dev/null && kill -KILL "$PID" 2>/dev/null || true
      update_job_status "$JOB_ID" "terminated" "143" || true

      [[ "$first" == "true" ]] || printf ','
      first=false
      printf '{"job_id": "%s", "pid": %s, "command": "%s"}' \
        "$JOB_ID" "$PID" "$(json_escape "$COMMAND")" || true
      ((terminated_count++)) || true
    fi
  done

  printf '], "count": %d, "timestamp": "%s"}\n' \
    "$terminated_count" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}

format_jobs_pretty() {
  local job_count=0

  # Header
  printf '%-20s %-8s %-12s %-50s %s\n' "JOB ID" "PID" "STATUS" "COMMAND" "START TIME"
  # Separator line (130 dashes)
  printf '%*s\n' 130 | tr ' ' '-'

  # Rows
  for job_file in "${JOBS_DIR}"/*.job; do
    [[ -f "$job_file" ]] || continue

    local JOB_ID="" PID="" COMMAND="" STATUS="" START_TIME="" EXIT_CODE="" END_TIME=""
    # shellcheck disable=SC1090
    source "$job_file"

    # Refresh status for running jobs
    if [[ "$STATUS" == "running" ]] && ! kill -0 "$PID" 2>/dev/null; then
      STATUS="completed"
    fi

    # Truncate long commands
    local cmd_display="${COMMAND:0:48}"
    [[ ${#COMMAND} -gt 48 ]] && cmd_display="${cmd_display}..."
    printf '%-20s %-8s %-12s %-50s %s\n' "$JOB_ID" "$PID" "$STATUS" "$cmd_display" "$START_TIME"
    ((++job_count))
  done

  # Footer
  [[ $job_count -gt 0 ]] && printf '%*s\n' 130 | tr ' ' '-'
  printf 'Total: %d job(s) | Updated: %s\n' "$job_count" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}

list_jobs() {
  init_jobs_dir
  local pretty="${1:-false}"

  if [[ "$pretty" == "true" ]]; then
    format_jobs_pretty
    return
  fi

  local first=true
  printf '{"jobs": ['

  for job_file in "${JOBS_DIR}"/*.job; do
    [[ -f "$job_file" ]] || continue

    local JOB_ID="" PID="" COMMAND="" STATUS="" START_TIME="" EXIT_CODE="" END_TIME=""
    # shellcheck disable=SC1090
    source "$job_file"

    # Refresh status for running jobs
    if [[ "$STATUS" == "running" ]] && ! kill -0 "$PID" 2>/dev/null; then
      STATUS="completed"
    fi

    [[ "$first" == "true" ]] || printf ','
    first=false

    printf '{"job_id": "%s", "pid": %s, "status": "%s", "command": "%s", "start_time": %s}' \
      "$JOB_ID" "$PID" "$STATUS" "$(json_escape "$COMMAND")" "$START_TIME"
  done

  printf '], "count": %d, "timestamp": "%s"}\n' \
    "$(find "$JOBS_DIR" -name '*.job' 2>/dev/null | wc -l | tr -d ' ')" \
    "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}

cleanup_jobs() {
  init_jobs_dir
  local cleaned=0
  shopt -s nullglob  # Make glob expand to nothing if no matches
  for job_file in "${JOBS_DIR}"/*.job; do
    local JOB_ID="" PID="" STATUS=""
    # shellcheck disable=SC1090
    source "$job_file" || continue

    # Check if job is finished or process is dead
    local should_clean=false
    if [[ "$STATUS" != "running" ]]; then
      should_clean=true
    elif ! kill -0 "$PID" 2>/dev/null; then
      should_clean=true
    fi

    if [[ "$should_clean" == "true" ]]; then
      rm -f "$job_file" "${JOBS_DIR}/${JOB_ID}.stdout" "${JOBS_DIR}/${JOB_ID}.stderr"
      ((cleaned++))
    fi
  done
  shopt -u nullglob  # Reset
  printf '{"cleaned": %d, "timestamp": "%s"}\n' "$cleaned" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}

# =============================================================================
# Usage
# =============================================================================

usage() {
  cat <<'EOF'
Universal CLI Execution Tool v1.0.0

USAGE:
  actuator [OPTIONS] <command>
  actuator [OPTIONS] -- <command args...>
  actuator [OPTIONS] --stdin
  echo "command" | actuator [OPTIONS]
  actuator --poll <job_id>
  actuator --terminate <job_id> [signal]
  actuator --terminate-all
  actuator --list
  actuator --cleanup

OPTIONS:
  -c, --command <cmd>     Command to execute
  -a, --async             Execute asynchronously (returns job ID)
  -s, --stream            Stream real-time status updates (sync mode or with -p for async)
  -t, --timeout <sec>     Timeout in seconds (0 = no timeout)
  -p, --poll <job_id>     Poll status of async job (use -s for continuous monitoring)
  -k, --terminate <id>    Terminate async job
  --terminate-all         Terminate all running jobs
  -l, --list              List all tracked jobs (JSON output)
  --pretty                Format output as aligned table (use with -l)
  --cleanup               Remove completed job artifacts
  --stdin                 Read command from stdin (for shell metacharacters)
  --plain                 Output plain text instead of JSON
  -q, --quiet             Suppress command output from terminal and metadata
  -v, --version           Show version
  -h, --help              Show this help

EXAMPLES:
  # Synchronous execution
  actuator "echo 'hello world'"
  actuator -c "ls -la /tmp"
  actuator -- ls -la /tmp

  # With timeout (30 seconds)
  actuator -t 30 "sleep 60"
  actuator -t 30 -- sleep 60

  # Stream real-time status
  actuator -s -- make build

  # Suppress command output, keep metadata only
  actuator -q "git diff --staged ./"
  actuator --quiet --plain "npm test"

  # Async execution
  actuator -a -- npm install
  actuator --poll 1738800000_12345                 # Single poll
  actuator -p 1738800000_12345 -s                  # Continuous polling with heartbeat
  actuator --terminate 1738800000_12345

  # Commands with shell metacharacters (;, |, &&)
  actuator --stdin <<< 'while :; do echo tick; sleep 1; done'
  echo 'ls -la | grep txt' | actuator
  actuator -t 5 --stdin <<< 'while :; do echo tick; sleep 1; done'

  # Multi-line commands using heredoc
  cat << 'HEREDOC' | actuator
    ls -la
    echo "---"
    pwd
  HEREDOC
  
  # With timeout
  cat << 'HEREDOC' | actuator -t 30
    sleep 5
    echo "done"
  HEREDOC
  
  # Async multi-line
  cat << 'HEREDOC' | actuator -a
    npm install
    npm run build
  HEREDOC

  # Job management
  actuator --list                    # JSON output
  actuator --pretty --list           # Formatted table
  actuator --terminate-all
  actuator --cleanup

ENVIRONMENT:
  ACTUATOR_JOBS_DIR        Job storage directory (default: /tmp/actuator-jobs)
  ACTUATOR_STATUS_INTERVAL Status update interval in seconds (default: 2)

OUTPUT:
  All output is JSON-structured for AI consumption.
  Use --plain for human-readable plain text output.
EOF
}

# =============================================================================
# Main
# =============================================================================

main() {
  local command="" mode="sync" timeout="$DEFAULT_TIMEOUT"
  local stream="false" plain="false" use_tty="false" quiet="false" pretty="false"
  local poll_id="" terminate_id="" terminate_signal="TERM" list_jobs_flag="false"

  # Get execution sequence number (global for all functions)
  EXEC_SEQUENCE=$(get_next_sequence)

  # Auto-detect piped stdin when no args
  if [[ $# -eq 0 ]]; then
    if [[ ! -t 0 ]]; then
      command=$(cat)
    else
      usage
      exit 0
    fi
  fi

  # Auto-enable TTY if stdin is a terminal (nothing piped)
  # TTY mode runs commands in the FOREGROUND so they get real terminal access.
  # This allows interactive commands (ssh) and isatty-dependent commands (cdiff)
  # to work correctly. Output goes directly to the user's terminal.
  if [[ -t 0 && "$use_tty" == "false" ]]; then
    use_tty="true"
  fi

  # Disable TTY when streaming is requested - streaming requires polling mode
  # to emit heartbeat events. This ensures -s flag always gets heartbeat support.
  if [[ "$stream" == "true" ]]; then
    use_tty="false"
  fi

  # First pass: collect all flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -c|--command)
        command="$2"; shift 2 ;;
      -a|--async)
        mode="async"; shift ;;
      -s|--stream)
        stream="true"; shift ;;
      -t|--timeout)
        timeout="$2"; shift 2 ;;
      -p|--poll)
        poll_id="$2"; shift 2 ;;
      -k|--terminate)
        terminate_id="$2"
        shift 2
        [[ $# -gt 0 && "$1" != -* ]] && { terminate_signal="$1"; shift; }
        ;;
      --pretty)
        pretty="true"; shift ;;
      --stdin)
        command=$(cat); shift ;;
      --plain)
        plain="true"; shift ;;
      -q|--quiet)
        quiet="true"; shift ;;
      -v|--version)
        printf '{"version": "%s"}\n' "$VERSION"; exit 0 ;;
      -h|--help)
        usage; exit 0 ;;
      -l|--list)
        list_jobs_flag="true"; shift ;;
      --terminate-all)
        terminate_all_jobs; exit 0 ;;
      --cleanup)
        cleanup_jobs || true  # Ignore any errors from cleanup
        wait  # Wait for any remaining background jobs
        exit 0 ;;
      --)
        shift; command="$*"; break ;;
      -*)
        printf '{"error": "Unknown option: %s"}\n' "$1" >&2; exit 1 ;;
      *)
        command="$*"; break ;;
    esac
  done

  # Handle deferred actions
  if [[ "$list_jobs_flag" == "true" ]]; then
    list_jobs "$pretty"
    exit 0
  fi

  # Handle job operations
  if [[ -n "$poll_id" ]]; then
    if [[ "$stream" == "true" ]]; then
      poll_job_stream "$poll_id"
    else
      poll_job "$poll_id"
    fi
    exit $?
  fi

  if [[ -n "$terminate_id" ]]; then
    terminate_job "$terminate_id" "$terminate_signal"
    exit $?
  fi

  # Validate command
  if [[ -z "$command" ]]; then
    printf '{"error": "No command specified. Use -h for help."}\n' >&2
    exit 1
  fi

  # Execute
  case "$mode" in
    sync)
      execute_sync "$command" "$timeout" "$stream" "$plain" "$use_tty" "$quiet"
      ;;
    async)
      execute_async "$command" "$timeout" "$plain" "$use_tty" "$quiet"
      ;;
  esac
}

main "$@"
